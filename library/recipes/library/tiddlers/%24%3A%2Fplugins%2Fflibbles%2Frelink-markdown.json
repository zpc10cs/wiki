{"name":"Relink Markdown","title":"$:/plugins/flibbles/relink-markdown","description":"Markdown support for Relink","author":"Flibbles","version":"2.0.0","core-version":">=5.1.22","parent-plugin":"$:/plugins/flibbles/relink","source":"https://github.com/flibbles/tw5-relink","list":"readme","dependents":"","plugin-type":"plugin","type":"application/json","text":"{\"tiddlers\":{\"$:/plugins/flibbles/relink/js/fieldtypes/markdown.js\":{\"title\":\"$:/plugins/flibbles/relink/js/fieldtypes/markdown.js\",\"text\":\"/*\\\\\\r\\nmodule-type: relinkfieldtype\\r\\ntitle: $:/plugins/flibbles/relink/js/fieldtypes/markdown.js\\r\\ntype: application/javascript\\r\\n\\r\\nThis relinks tiddlers which contain markdown. It tries to be agnostic to\\r\\nwhichever markdown plugin you're using.\\r\\n\\r\\n\\\\*/\\r\\n\\r\\nvar Rebuilder = require(\\\"$:/plugins/flibbles/relink/js/utils/rebuilder.js\\\");\\r\\nvar wikitextHandler = require(\\\"$:/plugins/flibbles/relink/js/utils.js\\\").getType('wikitext');\\r\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown.js\\\");\\r\\nvar WikiParser = require(\\\"$:/core/modules/parsers/wikiparser/wikiparser.js\\\")['text/vnd.tiddlywiki'];\\r\\n\\r\\nfunction MarkdownWalker(text, options) {\\r\\n\\tthis.wiki = options.wiki;\\r\\n\\tthis.options = Object.create(options);\\r\\n\\tthis.options.macrodefCanBeDisabled = true;\\r\\n\\tif(!this.mdInlineRuleClasses) {\\r\\n\\t\\tMarkdownWalker.prototype.mdInlineRuleClasses = $tw.modules.createClassesFromModules(\\\"relinkmarkdownrule\\\",\\\"inline\\\",$tw.MarkdownRuleBase);\\r\\n\\t}\\r\\n\\tif(!this.mdBlockRuleClasses) {\\r\\n\\t\\tMarkdownWalker.prototype.mdBlockRuleClasses = $tw.modules.createClassesFromModules(\\\"relinkmarkdownrule\\\",\\\"block\\\",$tw.MarkdownRuleBase);\\r\\n\\t}\\r\\n\\tthis.source = text || \\\"\\\";\\r\\n\\tthis.sourceLength = this.source.length;\\r\\n\\t// Set current parse position\\r\\n\\tthis.pos = 0;\\r\\n\\t// Instantiate the parser block and inline rules\\r\\n\\tthis.blockRules = this.instantiateRules(this.mdBlockRuleClasses,\\\"block\\\",0);\\r\\n\\tthis.inlineRules = this.instantiateRules(this.mdInlineRuleClasses,\\\"inline\\\",0);\\r\\n\\t// instantiateRules first with indent==undefined so we can match regardless\\r\\n\\t// of tabdepth. Now we need to be strict about it.\\r\\n\\tthis.indent = 0;\\r\\n\\tthis.parseBlocks();\\r\\n};\\r\\n\\r\\nMarkdownWalker.prototype = Object.create(WikiParser.prototype);\\r\\n\\r\\nmodule.exports\\r\\n\\r\\nMarkdownWalker.prototype.parseBlock = function(terminatorRegExpString) {\\r\\n\\tvar terminatorRegExp = /([^\\\\S\\\\n]*\\\\r?\\\\n)/mg;\\r\\n\\tthis.skipEmptyLines();\\r\\n\\tif(this.pos >= this.sourceLength) {\\r\\n\\t\\treturn [];\\r\\n\\t}\\r\\n\\t// Look for a block rule that applies at the current position\\r\\n\\tvar nextMatch = this.findNextMatch(this.blockRules, this.pos);\\r\\n\\tif(nextMatch && nextMatch.matchIndex === this.pos) {\\r\\n\\t\\treturn this.handleRule(nextMatch);\\r\\n\\t}\\r\\n\\treturn this.parseInlineRun(terminatorRegExp);\\r\\n};\\r\\n\\r\\nMarkdownWalker.prototype.parseInlineRunTerminated = function(terminatorRegExp,options) {\\r\\n\\toptions = options || {};\\r\\n\\tvar tree = [];\\r\\n\\t// Find the next occurrence of the terminator\\r\\n\\tterminatorRegExp.lastIndex = this.pos;\\r\\n\\tvar terminatorMatch = terminatorRegExp.exec(this.source);\\r\\n\\t// Find the next occurrence of a inlinerule\\r\\n\\tvar inlineRuleMatch = this.findNextMatch(this.inlineRules,this.pos);\\r\\n\\t// Loop around until we've reached the end of the text\\r\\n\\twhile(this.pos < this.sourceLength && (terminatorMatch || inlineRuleMatch)) {\\r\\n\\t\\t// Return if we've found the terminator, and it precedes any inline rule match\\r\\n\\t\\tif(terminatorMatch) {\\r\\n\\t\\t\\tif(!inlineRuleMatch || inlineRuleMatch.matchIndex >= terminatorMatch.index) {\\r\\n\\t\\t\\t\\tthis.handleWikitext(this.pos, terminatorMatch.index);\\r\\n\\t\\t\\t\\t//if(options.eatTerminator) {\\r\\n\\t\\t\\t\\t\\tthis.pos += terminatorMatch[0].length;\\r\\n\\t\\t\\t\\t//}\\r\\n\\t\\t\\t\\treturn tree;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t// Process any inline rule, along with the text preceding it\\r\\n\\t\\tif(inlineRuleMatch) {\\r\\n\\t\\t\\t// Preceding text\\r\\n\\t\\t\\tthis.handleWikitext(this.pos, inlineRuleMatch.matchIndex);\\r\\n\\t\\t\\tthis.handleRule(inlineRuleMatch);\\r\\n\\t\\t\\t// Look for the next inline rule\\r\\n\\t\\t\\tinlineRuleMatch = this.findNextMatch(this.inlineRules,this.pos);\\r\\n\\t\\t\\t// Look for the next terminator match\\r\\n\\t\\t\\tterminatorRegExp.lastIndex = this.pos;\\r\\n\\t\\t\\tterminatorMatch = terminatorRegExp.exec(this.source);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t// Process the remaining text\\r\\n\\tthis.handleWikitext(this.pos, this.sourceLength);\\r\\n\\treturn tree;\\r\\n};\\r\\n\\r\\nMarkdownWalker.prototype.skipEmptyLines = function() {\\r\\n\\tvar emptyRegExp = /(?:[^\\\\S\\\\n]*\\\\n)+/mg;\\r\\n\\temptyRegExp.lastIndex = this.pos;\\r\\n\\tvar emptyMatch = emptyRegExp.exec(this.source);\\r\\n\\tif(emptyMatch && emptyMatch.index === this.pos) {\\r\\n\\t\\tthis.pos = emptyRegExp.lastIndex;\\r\\n\\t}\\r\\n};\\r\\n\\r\\nfunction MarkdownReporter(text, callback, options) {\\r\\n\\tthis.callback = callback;\\r\\n\\tMarkdownWalker.call(this, text, options);\\r\\n};\\r\\n\\r\\nMarkdownReporter.prototype = Object.create(MarkdownWalker.prototype);\\r\\n\\r\\nMarkdownReporter.prototype.handleRule = function(ruleInfo) {\\r\\n\\tif (ruleInfo.rule.report) {\\r\\n\\t\\truleInfo.rule.report(this.source, this.callback, this.options);\\r\\n\\t} else {\\r\\n\\t\\tif (ruleInfo.rule.matchRegExp !== undefined) {\\r\\n\\t\\t\\tthis.pos = ruleInfo.rule.matchRegExp.lastIndex;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t// We can't easily determine the end of this\\r\\n\\t\\t\\t// rule match. We'll \\\"parse\\\" it so that\\r\\n\\t\\t\\t// parser.pos gets updated, but we throw away\\r\\n\\t\\t\\t// the results.\\r\\n\\t\\t\\truleInfo.rule.parse();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\nMarkdownReporter.prototype.handleWikitext = function(startPos, end) {\\r\\n\\tif (startPos < end) {\\r\\n\\t\\tvar config = utils.getSettings(this.wiki);\\r\\n\\t\\tif (config.wikitext) {\\r\\n\\t\\t\\tvar substr = this.source.substring(this.pos, end);\\r\\n\\r\\n\\t\\t\\tvar pragma = config.wikitextPragma;\\r\\n\\t\\t\\tvar wikiEntry = wikitextHandler.report(pragma + substr, this.callback, this.options);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tthis.pos = end;\\r\\n};\\r\\n\\r\\nexports.report = function(markdowntext, callback, options) {\\r\\n\\tnew MarkdownReporter(markdowntext, callback, options);\\r\\n};\\r\\n\\r\\nfunction MarkdownRelinker(text, fromTitle, toTitle, options) {\\r\\n\\tthis.fromTitle = fromTitle;\\r\\n\\tthis.toTitle = toTitle;\\r\\n\\tthis.builder = new Rebuilder(text);\\r\\n\\tMarkdownWalker.call(this, text, options);\\r\\n};\\r\\n\\r\\nMarkdownRelinker.prototype = Object.create(MarkdownWalker.prototype);\\r\\n\\r\\nMarkdownRelinker.prototype.handleRule = function(ruleInfo) {\\r\\n\\tvar newEntry = ruleInfo.rule.relink(this.source, this.fromTitle, this.toTitle, this.options);\\r\\n\\tif (newEntry !== undefined) {\\r\\n\\t\\tif (newEntry.impossible) {\\r\\n\\t\\t\\tthis.impossible = true;\\r\\n\\t\\t}\\r\\n\\t\\tif (newEntry.output) {\\r\\n\\t\\t\\tthis.builder.add(newEntry.output, ruleInfo.matchIndex, this.pos);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\nMarkdownRelinker.prototype.handleWikitext = function(startPos, end) {\\r\\n\\tif (startPos < end) {\\r\\n\\t\\tvar config = utils.getSettings(this.wiki);\\r\\n\\t\\tif (config.wikitext) {\\r\\n\\t\\t\\tvar substr = this.source.substring(this.pos, end);\\r\\n\\r\\n\\t\\t\\tvar pragma = config.wikitextPragma;\\r\\n\\t\\t\\tvar wikiEntry = wikitextHandler.relink(pragma + substr, this.fromTitle, this.toTitle, this.options);\\r\\n\\t\\t\\tif (wikiEntry != undefined) {\\r\\n\\t\\t\\t\\tif (wikiEntry.impossible) {\\r\\n\\t\\t\\t\\t\\tthis.impossible = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (wikiEntry.output) {\\r\\n\\t\\t\\t\\t\\tthis.builder.add(wikiEntry.output.slice(pragma.length), startPos, end);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tthis.pos = end;\\r\\n};\\r\\n\\r\\nexports.name = \\\"markdown\\\";\\r\\n\\r\\nexports.relink = function(markdowntext, fromTitle, toTitle, options) {\\r\\n\\tvar relinker = new MarkdownRelinker(markdowntext, fromTitle, toTitle, options),\\r\\n\\t\\tentry;\\r\\n\\tif (relinker.builder.changed() || relinker.impossible) {\\r\\n\\t\\tentry = {\\r\\n\\t\\t\\toutput: relinker.builder.results(),\\r\\n\\t\\t\\timpossible: relinker.impossible };\\r\\n\\t}\\r\\n\\treturn entry;\\r\\n};\\r\\n\",\"module-type\":\"relinkfieldtype\",\"type\":\"application/javascript\"},\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeblock.js\":{\"title\":\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeblock.js\",\"text\":\"/*\\\\\\r\\nmodule-type: relinkmarkdownrule\\r\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeblock.js\\r\\ntype: application/javascript\\r\\n\\r\\n```javascript\\r\\ncode\\r\\n```\\r\\n\\r\\n\\\\*/\\r\\n\\r\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown\\\");\\r\\n\\r\\nexports.name = \\\"codeblock\\\";\\r\\nexports.types = {inline: true};\\r\\n\\r\\nexports.init = function(parser) {\\r\\n\\tthis.parser = parser;\\r\\n\\tthis.matchRegExp = /(```+)[^\\\\n`]*(?:\\\\n|$)/mg;\\r\\n\\tthis.maxIndent = 3;\\r\\n};\\r\\n\\r\\nexports.relink = function(text, fromTitle, toTitle, options) {\\r\\n\\tvar endRegExp = new RegExp(\\\"^ {0,3}\\\" + this.match[1] + \\\"+[^\\\\\\\\S\\\\\\\\n]*\\\\\\\\n\\\", \\\"mg\\\");\\r\\n\\tendRegExp.lastIndex = this.matchRegExp.lastIndex;\\r\\n\\tvar endMatch = endRegExp.exec(this.parser.source);\\r\\n\\tif (endMatch) {\\r\\n\\t\\tthis.parser.pos = endRegExp.lastIndex;\\r\\n\\t} else {\\r\\n\\t\\tthis.parser.pos = this.parser.sourceLength;\\r\\n\\t}\\r\\n\\treturn undefined;\\r\\n};\\r\\n\\r\\nexports.report = exports.relink;\\r\\n\",\"module-type\":\"relinkmarkdownrule\",\"type\":\"application/javascript\"},\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeinline.js\":{\"title\":\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeinline.js\",\"text\":\"/*\\\\\\r\\nmodule-type: relinkmarkdownrule\\r\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeinline.js\\r\\ntype: application/javascript\\r\\n\\r\\nHandles markdown `code` and ``code``.\\r\\n\\r\\n\\\\*/\\r\\n\\r\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown\\\");\\r\\n\\r\\nexports.name = \\\"codeinline\\\";\\r\\nexports.types = {inline: true};\\r\\n\\r\\nexports.init = function(parser) {\\r\\n\\tthis.parser = parser;\\r\\n};\\r\\n\\r\\nexports.findNextMatch = function(startPos) {\\r\\n\\tvar match, matchRegExp = /`+/mg;\\r\\n\\tmatchRegExp.lastIndex = startPos;\\r\\n\\twhile (match = matchRegExp.exec(this.parser.source)) {\\r\\n\\t\\tvar next = this.parser.source.indexOf(match[0], matchRegExp.lastIndex);\\r\\n\\t\\t// make sure we find the corresponding ticks\\r\\n\\t\\tif (next >= 0) {\\r\\n\\t\\t\\t// Make sure it's the right length\\r\\n\\t\\t\\tvar end = next + match[0].length;\\r\\n\\t\\t\\tif (match[0].length < 3 || !isLineStart(this.parser.source, next)) {\\r\\n\\t\\t\\t\\tif (this.parser.source.charAt(end) !== '`') {\\r\\n\\t\\t\\t\\t\\t// make sure there aren't paragraph breaks between the points\\r\\n\\t\\t\\t\\t\\tvar nextGraph = utils.indexOfParagraph(this.parser.source, matchRegExp.lastIndex);\\r\\n\\t\\t\\t\\t\\tif (nextGraph < 0 || nextGraph > next) {\\r\\n\\t\\t\\t\\t\\t\\tthis.end = end;\\r\\n\\t\\t\\t\\t\\t\\treturn match.index;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn undefined;\\r\\n};\\r\\n\\r\\nfunction isLineStart(text, pos) {\\r\\n\\t// if 3 or less spaces precede it, it's a line start.\\r\\n\\tvar p = text.lastIndexOf('\\\\n', pos);\\r\\n\\tif (pos - p > 3) {\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\twhile (++p < pos) {\\r\\n\\t\\tif (text.charAt(p) !== ' ') {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn true;\\r\\n};\\r\\n\\r\\nexports.relink = function() {\\r\\n\\tthis.parser.pos = this.end;\\r\\n\\treturn undefined;\\r\\n};\\r\\n\\r\\nexports.report = exports.relink;\\r\\n\",\"module-type\":\"relinkmarkdownrule\",\"type\":\"application/javascript\"},\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/footnote.js\":{\"title\":\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/footnote.js\",\"text\":\"/*\\\\\\r\\nmodule-type: relinkmarkdownrule\\r\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/footnote.js\\r\\ntype: application/javascript\\r\\n\\r\\nHandles markdown footnotes\\r\\n\\r\\n[1]: #link\\r\\n\\r\\n\\\\*/\\r\\n\\r\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown\\\");\\r\\n\\r\\nexports.name = \\\"markdownfootnote\\\";\\r\\nexports.types = {block: true};\\r\\n\\r\\nexports.init = function(parser) {\\r\\n\\tthis.parser = parser;\\r\\n\\tthis.matchRegExp = /\\\\[((?:[^\\\\\\\\\\\\]]|\\\\\\\\.)*)\\\\]:(\\\\s*)(#?)(\\\\S+)([^\\\\S\\\\n]*(?:\\\\n|$))/mg;\\r\\n\\tthis.maxIndent = 3;\\r\\n};\\r\\n\\r\\nexports.report = function(text, callback, options) {\\r\\n\\tvar m = this.match,\\r\\n\\t\\tlink = decodeURIComponent(m[4]),\\r\\n\\t\\tentry;\\r\\n\\tthis.parser.pos = m.index + m[0].length;\\r\\n\\tif (m[1].charAt(0) !== \\\"^\\\"\\r\\n\\t && (m[3] === \\\"#\\\" || options.wiki.isImageTiddler(link))) {\\r\\n\\t\\tcallback(link, '[' + utils.abridge(m[1]) + ']:');\\r\\n\\t}\\r\\n};\\r\\n\\r\\nexports.relink = function(text, fromTitle, toTitle, options) {\\r\\n\\tvar m = this.match,\\r\\n\\t\\tlink = m[4],\\r\\n\\t\\tentry;\\r\\n\\tthis.parser.pos = m.index + m[0].length;\\r\\n\\tif (m[1].charAt(0) !== \\\"^\\\"\\r\\n\\t && (m[3] === \\\"#\\\" || options.wiki.isImageTiddler(toTitle))\\r\\n\\t && decodeURIComponent(link) === fromTitle) {\\r\\n\\t\\tentry = { output: this.indentString + \\\"[\\\" + m[1] + \\\"]:\\\" + m[2] + m[3] + utils.encodeLink(toTitle) + m[5] };\\r\\n\\t}\\r\\n\\treturn entry;\\r\\n};\\r\\n\",\"module-type\":\"relinkmarkdownrule\",\"type\":\"application/javascript\"},\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/link.js\":{\"title\":\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/link.js\",\"text\":\"/*\\\\\\r\\nmodule-type: relinkmarkdownrule\\r\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/link.js\\r\\ntype: application/javascript\\r\\n\\r\\nHandles markdown links\\r\\n\\r\\n[caption](#link)\\r\\n\\r\\n\\\\*/\\r\\n\\r\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown\\\");\\r\\nvar markdown = require(\\\"$:/plugins/flibbles/relink/js/utils\\\").getType('markdown');\\r\\n\\r\\nexports.name = \\\"markdownlink\\\";\\r\\nexports.types = {inline: true};\\r\\n\\r\\nexports.init = function(parser) {\\r\\n\\tthis.parser = parser;\\r\\n};\\r\\n\\r\\nexports.findNextMatch = function(startPos) {\\r\\n\\tthis.endMatch = this.matchLink(this.parser.source, startPos);\\r\\n\\treturn this.endMatch ? this.endMatch.index : undefined;\\r\\n};\\r\\n\\r\\n/**A zero side-effect method which returns a regexp which pretended to match\\r\\n * the whole link, caption and all. I do this instead of just using a\\r\\n * regexp to begin with, because markdown links require context-free grammar\\r\\n * matching.\\r\\n * Currently, it doesn't properly set match[0]. No need as of yet.\\r\\n * 1. \\\"!\\\"\\r\\n * 2. caption\\r\\n * 3. \\\"\\\\s*#?\\\"\\r\\n * 4. \\\"link\\\"\\r\\n * 5. \\\"\\\\s*'tooltip'\\\"\\r\\n */\\r\\nexports.matchLink = function(text, pos) {\\r\\n\\tpos = pos-1;\\r\\n\\tvar match = undefined;\\r\\n\\tdo {\\r\\n\\t\\tpos = text.indexOf('[', pos+1);\\r\\n\\t\\tif (pos < 0) {\\r\\n\\t\\t\\treturn undefined;\\r\\n\\t\\t}\\r\\n\\t\\tvar caption = this.getEnclosed(text, pos, '[', ']');\\r\\n\\t\\tif (caption === undefined) {\\r\\n\\t\\t\\tcontinue;\\r\\n\\t\\t}\\r\\n\\t\\tvar linkStart = pos + caption.length+2;\\r\\n\\t\\tif (text.charAt(linkStart) !== '(') {\\r\\n\\t\\t\\tcontinue;\\r\\n\\t\\t}\\r\\n\\t\\t// match[1] and match[2] are the \\\"!\\\" and \\\"caption\\\", filled in later.\\r\\n\\t\\tvar regExp = /\\\\(()()(\\\\s*#?)((?:[^\\\\s\\\\(\\\\)]|\\\\([^\\\\s\\\\(\\\\)]*\\\\))+)((?:\\\\s+(?:'(?:[^'\\\\\\\\]|\\\\\\\\.)*'|\\\"(?:[^\\\"\\\\\\\\]|\\\\\\\\.)*\\\"|\\\\([^)]*\\\\)))?\\\\s*)\\\\)/g;\\r\\n\\t\\tregExp.lastIndex = linkStart;\\r\\n\\t\\tmatch = regExp.exec(text);\\r\\n\\t\\tif (match && match.index === linkStart && utils.indexOfParagraph(match[0]) < 0) {\\r\\n\\t\\t\\tmatch[2] = caption;\\r\\n\\t\\t\\tif (text.charAt(pos-1) === \\\"!\\\") {\\r\\n\\t\\t\\t\\tmatch.index = pos-1;\\r\\n\\t\\t\\t\\tmatch[1] = \\\"!\\\";\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tmatch.index = pos;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tmatch = undefined;\\r\\n\\t\\t}\\r\\n\\t} while (!match);\\r\\n\\treturn match;\\r\\n};\\r\\n\\r\\nexports.report = function(text, callback, options) {\\r\\n\\tvar em = this.endMatch,\\r\\n\\t\\tcaption = em[2],\\r\\n\\t\\tprefix = em[1],\\r\\n\\t\\tisImage = (prefix === '!'),\\r\\n\\t\\tlink = em[4],\\r\\n\\t\\thash = '#';\\r\\n\\tif (prefix) {\\r\\n\\t\\thash = '';\\r\\n\\t}\\r\\n\\tthis.parser.pos = em.index + em[1].length + caption.length + em[0].length + 2;\\r\\n\\tif (!isImage) {\\r\\n\\t\\tmarkdown.report(caption, function(title, blurb) {\\r\\n\\t\\t\\tcallback(title, prefix + '[' + (blurb || '') + '](' + hash + link + ')');\\r\\n\\t\\t}, options);\\r\\n\\t}\\r\\n\\tif (isImage !== (em[3].lastIndexOf('#') >= 0)) {\\r\\n\\t\\tvar safeCaption = utils.abridge(caption);\\r\\n\\t\\ttry {\\r\\n\\t\\t\\tcallback(decodeURIComponent(link), em[1] + '[' + safeCaption + '](' + hash + ')');\\r\\n\\t\\t} catch (e) {\\r\\n\\t\\t\\t// It must be a malformed link. Not our problem.\\r\\n\\t\\t\\t// Just move on.\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\nexports.relink = function(text, fromTitle, toTitle, options) {\\r\\n\\tvar entry = {},\\r\\n\\t\\tem = this.endMatch,\\r\\n\\t\\tmodified = false,\\r\\n\\t\\tcaption = em[2],\\r\\n\\t\\tisImage = (em[1] === '!'),\\r\\n\\t\\tlink = em[4];\\r\\n\\tthis.parser.pos = em.index + em[1].length + caption.length + em[0].length + 2;\\r\\n\\tif (!isImage) {\\r\\n\\t\\tvar newCaption = markdown.relink(caption, fromTitle, toTitle, options);\\r\\n\\t\\tif (newCaption) {\\r\\n\\t\\t\\tif (newCaption.output) {\\r\\n\\t\\t\\t\\tif (this.canBeCaption(newCaption.output)) {\\r\\n\\t\\t\\t\\t\\tcaption = newCaption.output;\\r\\n\\t\\t\\t\\t\\tmodified = true;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tentry.impossible = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (newCaption.impossible) {\\r\\n\\t\\t\\t\\tentry.impossible = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t// I don't know why internal images links don't use the '#', but links\\r\\n\\t// do, but that's just how it is.\\r\\n\\tif (isImage !== (em[3].lastIndexOf('#') >=0)) {\\r\\n\\t\\ttry {\\r\\n\\t\\t\\tif (decodeURIComponent(link) === fromTitle) {\\r\\n\\t\\t\\t\\tlink = utils.encodeLink(toTitle);\\r\\n\\t\\t\\t\\tmodified = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} catch (e) {\\r\\n\\t\\t\\t// It must be a malformed link. Not our problem.\\r\\n\\t\\t\\t// Keep going in case the caption needs relinking.\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif (modified) {\\r\\n\\t\\t// This way preserves whitespace\\r\\n\\t\\tentry.output = em[1]+\\\"[\\\"+caption+\\\"](\\\"+em[3]+link+em[5]+\\\")\\\";\\r\\n\\t}\\r\\n\\tif (modified || entry.impossible) {\\r\\n\\t\\treturn entry;\\r\\n\\t}\\r\\n\\treturn undefined;\\r\\n};\\r\\n\\r\\nexports.canBeCaption = function(caption) {\\r\\n\\treturn this.indexOfClose(caption+']', -1, '[', ']') === caption.length;\\r\\n};\\r\\n\\r\\nexports.getEnclosed = function(text, pos, openChar, closeChar) {\\r\\n\\tvar capEnd = this.indexOfClose(text, pos, openChar, closeChar);\\r\\n\\tif (capEnd < 0) {\\r\\n\\t\\treturn undefined;\\r\\n\\t}\\r\\n\\tvar enclosed = text.substring(pos+1, capEnd);\\r\\n\\tif (enclosed.match(/\\\\n\\\\s*\\\\n/)) {\\r\\n\\t\\t// Paragraph breaks are not allowed\\r\\n\\t\\treturn undefined;\\r\\n\\t}\\r\\n\\treturn enclosed;\\r\\n};\\r\\n\\r\\nexports.indexOfClose = function(text, pos, openChar, closeChar) {\\r\\n\\tvar close = pos-1,\\r\\n\\t\\topen = pos; // First char is open\\r\\n\\tdo {\\r\\n\\t\\tclose = text.indexOf(closeChar, close+1);\\r\\n\\t\\tif (close < 0) {\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\t}\\r\\n\\t\\topen = text.indexOf(openChar, open+1);\\r\\n\\t} while (open >= 0 && open <= close);\\r\\n\\treturn close;\\r\\n};\\r\\n\",\"module-type\":\"relinkmarkdownrule\",\"type\":\"application/javascript\"},\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/markdownrulebase.js\":{\"title\":\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/markdownrulebase.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/markdownrulebase.js\\r\\ntype: application/javascript\\r\\nmodule-type: global\\r\\n\\r\\nBase class for markdown parser rules\\r\\n\\r\\n\\\\*/\\r\\n(function(){\\r\\n\\r\\n/*jslint node: true, browser: true */\\r\\n/*global $tw: false */\\r\\n\\\"use strict\\\";\\r\\n\\r\\nvar utils = require(\\\"$:/plugins/flibbles/relink/js/utils/markdown\\\");\\r\\n\\r\\nvar MarkdownRuleBase = function() {};\\r\\n\\r\\nMarkdownRuleBase.prototype.init = function(parser) {\\r\\n\\tthis.parser = parser;\\r\\n};\\r\\n\\r\\nMarkdownRuleBase.prototype.findNextMatch = function(startPos) {\\r\\n\\tthis.matchRegExp.lastIndex = startPos;\\r\\n\\twhile (this.match = this.matchRegExp.exec(this.parser.source)) {\\r\\n\\t\\tif (utils.indexOfParagraph(this.match[0]) >= 0) {\\r\\n\\t\\t\\tcontinue;\\r\\n\\t\\t}\\r\\n\\t\\tif (this.maxIndent !== undefined) {\\r\\n\\t\\t\\tvar indent = utils.indentation(this.parser.source,this.match.index);\\r\\n\\t\\t\\tif (indent < 0\\r\\n\\t\\t\\t || (this.parser.indent !== undefined\\r\\n\\t\\t\\t  && (indent > this.parser.indent + this.maxIndent))) {\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvar nl = this.parser.source.lastIndexOf('\\\\n', this.match.index-1)+1;\\r\\n\\t\\t\\tthis.indentString = this.parser.source.substring(nl, this.match.index);\\r\\n\\t\\t\\treturn nl < startPos ? startPos : nl;\\r\\n\\t\\t}\\r\\n\\t\\treturn this.match.index;\\r\\n\\t}\\r\\n\\treturn undefined;\\r\\n};\\r\\n\\r\\n\\r\\nexports.MarkdownRuleBase = MarkdownRuleBase;\\r\\n\\r\\n})();\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"global\"},\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext.js\":{\"title\":\"$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext.js\",\"text\":\"/*\\\\\\r\\nmodule-type: relinktextoperator\\r\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext.js\\r\\ntype: application/javascript\\r\\n\\r\\nThis relinks tiddlers which contain markdown. It tries to be agnostic to\\r\\nwhichever markdown plugin you're using.\\r\\n\\r\\n\\\\*/\\r\\n\\r\\n/*jslint node: false, browser: true */\\r\\n/*global $tw: false */\\r\\n\\\"use strict\\\";\\r\\n\\r\\nvar Placeholder = require(\\\"$:/plugins/flibbles/relink/js/utils/placeholder.js\\\");\\r\\nvar markdownHandler = require('$:/plugins/flibbles/relink/js/utils.js').getType('markdown');\\r\\n\\r\\nexports.type = \\\"text/x-markdown\\\";\\r\\n\\r\\nexports.report = function(tiddler, callback, options) {\\r\\n\\tmarkdownHandler.report(tiddler.fields.text, callback, options);\\r\\n};\\r\\n\\r\\nexports.relink = function(tiddler, fromTitle, toTitle, options) {\\r\\n\\tvar placeholder = new Placeholder();\\r\\n\\tvar extraOptions = $tw.utils.extend(\\r\\n\\t\\t{\\r\\n\\t\\t\\tplaceholder: placeholder\\r\\n\\t\\t}, options);\\r\\n\\tvar entry = markdownHandler.relink(tiddler.fields.text, fromTitle, toTitle, extraOptions);\\r\\n\\tif (entry && entry.output) {\\r\\n\\t\\t// If there's output, we've also got to prepend any macros\\r\\n\\t\\t// that the placeholder defined.\\r\\n\\t\\tvar preamble = placeholder.getPreamble();\\r\\n\\t\\tentry.output = preamble + entry.output\\r\\n\\t}\\r\\n\\treturn entry;\\r\\n};\\r\\n\",\"module-type\":\"relinktextoperator\",\"type\":\"application/javascript\"},\"$:/plugins/flibbles/relink/js/utils/markdown.js\":{\"title\":\"$:/plugins/flibbles/relink/js/utils/markdown.js\",\"text\":\"/*\\\\\\r\\nmodule-type: library\\r\\ntitle: $:/plugins/flibbles/relink/js/utils/markdown.js\\r\\ntype: application/javascript\\r\\n\\r\\nMethods used in markdown parsing.\\r\\n\\r\\n\\\\*/\\r\\n\\r\\n// tiddlywiki/markdown can't handle having these characters escaped, so we\\r\\n// need to unescape them.\\r\\nvar problemChars = {\\r\\n\\t\\\"23\\\": \\\"#\\\",\\r\\n\\t\\\"24\\\": \\\"$\\\",\\r\\n\\t\\\"26\\\": \\\"&\\\",\\r\\n\\t\\\"2B\\\": \\\"+\\\",\\r\\n\\t\\\"2C\\\": \\\",\\\",\\r\\n\\t\\\"2F\\\": \\\"/\\\",\\r\\n\\t\\\"3A\\\": \\\":\\\",\\r\\n\\t\\\"3B\\\": \\\";\\\",\\r\\n\\t\\\"3D\\\": \\\"=\\\",\\r\\n\\t\\\"3F\\\": \\\"?\\\",\\r\\n\\t\\\"40\\\": \\\"@\\\",\\r\\n};\\r\\n\\r\\nexports.encodeLink = function(title) {\\r\\n\\tvar encoded = encodeURIComponent(title),\\r\\n\\t\\tbalance = 0;\\r\\n\\tencoded = encoded.replace(/[\\\\(\\\\)]/g, function(p) {\\r\\n\\t\\tif (p === '(') {\\r\\n\\t\\t\\tif (balance >=1) {\\r\\n\\t\\t\\t\\treturn '%28';\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tbalance++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (balance <= 0) {\\r\\n\\t\\t\\t\\treturn '%29';\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tbalance--;\\r\\n\\t\\t}\\r\\n\\t\\treturn p;\\r\\n\\t});\\r\\n\\twhile (balance--) {\\r\\n\\t\\tvar i = encoded.lastIndexOf('(');\\r\\n\\t\\tencoded = encoded.substr(0, i) + '%28' + encoded.substr(i+1);\\r\\n\\t}\\r\\n\\t// tiddlywiki/markdown can't handle these characters escaped\\r\\n\\treturn encoded.replace(/%([0-9A-F]{2})/g, function(str, code) {\\r\\n\\t\\treturn problemChars[code] || str;\\r\\n\\t});\\r\\n};\\r\\n\\r\\n// Returns index of next paragraph, or -1\\r\\nexports.indexOfParagraph = function(text, startPos) {\\r\\n\\tvar regExp = /\\\\n\\\\s*\\\\n/mg;\\r\\n\\tregExp.lastIndex = startPos || 0;\\r\\n\\tvar match = regExp.exec(text);\\r\\n\\treturn match ? regExp.lastIndex : -1;\\r\\n};\\r\\n\\r\\n/** Returns how much indentation there is between pos and the previous\\r\\n * newline (or other char).\\r\\n * tabs are counted as 4 chars.\\r\\n */\\r\\nexports.indentation = function(text, pos, startChar) {\\r\\n\\tvar p = text.lastIndexOf(startChar || '\\\\n', pos-1);\\r\\n\\tvar count = 0;\\r\\n\\twhile (++p < pos) {\\r\\n\\t\\tvar c = text.charAt(p);\\r\\n\\t\\tif (c === ' ') {\\r\\n\\t\\t\\tcount++;\\r\\n\\t\\t} else if (c === '\\\\t') {\\r\\n\\t\\t\\tcount = count + 4 - (count%4);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn count;\\r\\n};\\r\\n\\r\\n\\r\\nexports.getSettings = function(wiki) {\\r\\n\\t// Stored here so it's only calculated once, but also so it's different\\r\\n\\t// per tiddler for testing\\r\\n\\tif (wiki._markdownSettings === undefined) {\\r\\n\\t\\tvar settings = Object.create(null);\\r\\n\\t\\tvar text = wiki.getTiddlerText(\\\"$:/config/markdown/renderWikiText\\\");\\r\\n\\t\\tsettings.wikitext =  (text === undefined || text.toLowerCase() === \\\"true\\\");\\r\\n\\t\\ttext = wiki.getTiddlerText(\\\"$:/config/markdown/renderWikiTextPragma\\\");\\r\\n\\t\\tif (text) {\\r\\n\\t\\t\\ttext = text.trim() + '\\\\n';\\r\\n\\t\\t} else {\\r\\n\\t\\t\\ttext = '';\\r\\n\\t\\t}\\r\\n\\t\\tsettings.wikitextPragma = text;\\r\\n\\t\\twiki._markdownSettings = settings;\\r\\n\\t}\\r\\n\\treturn wiki._markdownSettings;\\r\\n};\\r\\n\\r\\n// This is the maximum length a reported caption may be\\r\\nexports.captionLength = 15;\\r\\n\\r\\n/** Abridges a string to one that is more log-friendly.\\r\\n */\\r\\nexports.abridge = function(string) {\\r\\n\\tvar safe = string.replace(/\\\\s+/mg, ' ');\\r\\n\\tif (safe.length > this.captionLength) {\\r\\n\\t\\tsafe = safe.substr(0, this.captionLength) + \\\"...\\\";\\r\\n\\t}\\r\\n\\treturn safe;\\r\\n};\\r\\n\\r\\n/**I don't actually use this, but I've kept the code around anyway.\\r\\n * The only time this plugin is installed and markdown isn't enabled would\\r\\n * be if the user forgot to install a markdown plugin, or they disabled it.\\r\\n * I GUESS Relink should still be Relinking markdown in that case.\\r\\n */\\r\\nexports.markdownEnabled = function() {\\r\\n\\tif (_enabled === undefined) {\\r\\n\\t\\tvar test = $tw.wiki.renderText(\\\"text/html\\\", \\\"text/x-markdown\\\", \\\"[test](#test)\\\");\\r\\n\\t\\t_enabled = (test.indexOf(\\\"<a\\\") >= 0);\\r\\n\\t}\\r\\n\\treturn _enabled;\\r\\n};\\r\\nvar _enabled;\\r\\n\",\"module-type\":\"library\",\"type\":\"application/javascript\"},\"$:/plugins/flibbles/relink-markdown/readme\":{\"title\":\"$:/plugins/flibbles/relink-markdown/readme\",\"text\":\"Markdown support for Relink.\\n\\n...or Relink support for Markdown.\\n\\nThis supplimental plugin allows ''text/x-markdown'' files to be relinked. This means markdown linking syntax like `[Caption](#MyTiddler)` is supported. If your markdown supports wikitext markup as well, this will handle that too.\\n\\nThis plugin is designed for `tiddlywiki/markdown`, but it will also work for `anstosa/tw5-markdown` and others.\\r\\n\"}}}"}