{"title":"$:/plugins/tobibeer/appear","description":"Create popups, sliders or accordion menus with the appear widget.","author":"Tobias Beer","version":"0.6.2","core-version":">=5.1.9","source":"https://github.com/tobibeer/tw5-appear","documentation":"https://tobibeer.github.io/tw5-appear","plugin-type":"plugin","requires":"","list":"readme","dependents":"","type":"application/json","text":"{\"tiddlers\":{\"$:/plugins/tobibeer/appear/widget.js\":{\"title\":\"$:/plugins/tobibeer/appear/widget.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/tobibeer/appear/widget.js\\r\\ntype: application/javascript\\r\\nmodule-type: widget\\r\\n\\r\\nUse the appear widget for popups, sliders, accordion menus\\r\\n\\r\\n@preserve\\r\\n\\\\*/\\r\\n(function(){\\r\\n\\r\\n/*jslint node: true, browser: true */\\r\\n/*global $tw: false */\\r\\n\\\"use strict\\\";\\r\\n\\r\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget,\\r\\n\\tAppearWidget = function(parseTreeNode,options) {\\r\\n\\t\\tthis.initialise(parseTreeNode,options);\\r\\n\\t},\\r\\n\\thandlerCache = {};\\r\\n\\r\\n/*\\r\\nInherit from the base widget class\\r\\n*/\\r\\nAppearWidget.prototype = new Widget();\\r\\n\\r\\n/*\\r\\nRender this widget into the DOM\\r\\n*/\\r\\nAppearWidget.prototype.render = function(parent,nextSibling) {\\r\\n\\tthis.parentDomNode = parent;\\r\\n\\tthis.nextSibling = nextSibling;\\r\\n\\tthis.computeAttributes();\\r\\n\\tthis.execute();\\r\\n\\tvar cls,button,buttonClose,hidden,reveal,shown,\\r\\n\\t\\t// Will hold the child widgets\\r\\n\\t\\tnodes = [];\\r\\n\\t// Handler instance?\\r\\n\\tif(this.handle) {\\r\\n\\t\\t// Recreate cache\\r\\n\\t\\tthis.getHandlerCache(this.handle,1);\\r\\n\\t\\t// Handle refreshes\\r\\n\\t\\tthis.refreshHandler();\\r\\n\\t// Regular instance\\r\\n\\t} else {\\r\\n\\t\\t// Create button\\r\\n\\t\\tbutton = {type:\\\"button\\\"};\\r\\n\\t\\t// Init button attributes\\r\\n\\t\\tbutton.attributes = this.setAttributes(button,\\\"button\\\");\\r\\n\\t\\t// Store current classes\\r\\n\\t\\tcls = button.attributes[\\\"class\\\"].value.trim();\\r\\n\\t\\t// Add unselected class\\r\\n\\t\\tbutton.attributes[\\\"class\\\"].value = cls + \\\" appear-show\\\" + (this.handler ? \\\" tc-popup-absolute\\\" : \\\"\\\");\\r\\n\\t\\t// Parse label and add to children\\r\\n\\t\\tbutton.children = this.wiki.parseText(\\r\\n\\t\\t\\t\\\"text/vnd.tiddlywiki\\\",\\r\\n\\t\\t\\tthis.show,\\r\\n\\t\\t\\t{parseAsInline: true}\\r\\n\\t\\t).tree;\\r\\n\\t\\t// Create reveal\\r\\n\\t\\treveal = {type:\\\"reveal\\\",children:this.parseTreeNode.children};\\r\\n\\t\\t// Init reveal attributes\\r\\n\\t\\treveal.attributes = this.setAttributes(reveal,\\\"reveal\\\");\\r\\n\\t\\t// Set custom mode, if configured\\r\\n\\t\\treveal.isBlock = !(this.mode && this.mode === \\\"inline\\\");\\r\\n\\t\\t// Type popup?\\r\\n\\t\\tif(reveal.attributes.type && reveal.attributes.type.value === \\\"popup\\\") {\\r\\n\\t\\t\\t// Set button attribute for popup state\\r\\n\\t\\t\\tbutton.attributes.popup = reveal.attributes.state;\\r\\n\\t\\t\\t// Add childnodes\\r\\n\\t\\t\\tnodes.push(button);\\r\\n\\t\\t\\t// Unless we have a deferred handler defined\\r\\n\\t\\t\\tif(!this.handler) {\\r\\n\\t\\t\\t\\t// Push reveal to node tree\\r\\n\\t\\t\\t\\tnodes.push(reveal);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tbutton.attributes.handler = this.handler;\\r\\n\\t\\t\\t}\\r\\n\\t\\t// Not a popup\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t// Set reveal attribute for \\\"slider mode\\\"\\r\\n\\t\\t\\treveal.attributes.type = {type: \\\"string\\\", value: \\\"match\\\"};\\r\\n\\t\\t\\t// Must match current tiddler title\\r\\n\\t\\t\\treveal.attributes.text = {type: \\\"string\\\", value: this.currentTiddler};\\r\\n\\t\\t\\t// Button writes to state tiddler\\r\\n\\t\\t\\tbutton.attributes.set =  reveal.attributes.state;\\r\\n\\t\\t\\t// Sets to current tiddler\\r\\n\\t\\t\\tbutton.attributes.setTo =  {type: \\\"string\\\", value: this.currentTiddler};\\r\\n\\t\\t\\t// A wrapper reveal that will be hidden once the content is shown containing the button\\r\\n\\t\\t\\thidden = {type:\\\"reveal\\\",isBlock: this.block, children:[button], attributes: {\\r\\n\\t\\t\\t\\ttype: {type: \\\"string\\\", value: \\\"nomatch\\\"},\\r\\n\\t\\t\\t\\tstate: reveal.attributes.state,\\r\\n\\t\\t\\t\\ttext: {type: \\\"string\\\", value: this.currentTiddler}\\r\\n\\t\\t\\t}};\\r\\n\\t\\t\\t// Endless toggling?\\r\\n\\t\\t\\tif(!this.once) {\\r\\n\\t\\t\\t\\t// Create hide-button as a copy of the button\\r\\n\\t\\t\\t\\tbuttonClose = $tw.utils.deepCopy(button);\\r\\n\\t\\t\\t\\t// Add selected class\\r\\n\\t\\t\\t\\tbuttonClose.attributes[\\\"class\\\"].value = cls + \\\" appear-hide \\\" +\\r\\n\\t\\t\\t\\t\\t(this.attr.button.selectedClass ? this.attr.button.selectedClass : \\\"\\\");\\r\\n\\t\\t\\t\\t// However, resetting the state\\r\\n\\t\\t\\t\\tbuttonClose.attributes.setTo = {type: \\\"string\\\", value: \\\"\\\"};\\r\\n\\t\\t\\t\\t// Setting the hide-button label\\r\\n\\t\\t\\t\\tbuttonClose.children = this.wiki.parseText(\\r\\n\\t\\t\\t\\t\\t\\\"text/vnd.tiddlywiki\\\",\\r\\n\\t\\t\\t\\t\\tthis.hide,\\r\\n\\t\\t\\t\\t\\t{parseAsInline: true}\\r\\n\\t\\t\\t\\t).tree;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// Create a copy of the first reveal containing the button\\r\\n\\t\\t\\tshown = $tw.utils.deepCopy(hidden);\\r\\n\\t\\t\\t// Reset its children\\r\\n\\t\\t\\tshown.children = [];\\r\\n\\t\\t\\t// Endless toggling?\\r\\n\\t\\t\\tif(!this.once) {\\r\\n\\t\\t\\t\\t// Add close button\\r\\n\\t\\t\\t\\tshown.children.push(buttonClose);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// No remote handler?\\r\\n\\t\\t\\tif(!this.handler) {\\r\\n\\t\\t\\t\\t// Add slider contents\\r\\n\\t\\t\\t\\tshown.children.push(reveal);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// Switch reveal type for content reveal wrapper\\r\\n\\t\\t\\tshown.attributes.type.value = \\\"match\\\";\\r\\n\\t\\t\\t// Add wrapping reveals to output\\r\\n\\t\\t\\tnodes.push(hidden,shown);\\r\\n\\t\\t}\\r\\n\\t\\t// Construct the child widgets\\r\\n\\t\\tthis.makeChildWidgets(nodes);\\r\\n\\t\\t// Render into the dom\\r\\n\\t\\tthis.renderChildren(this.parentDomNode,nextSibling);\\r\\n\\t\\t// Now, do we have a remote handler?\\r\\n\\t\\tif(this.handler) {\\r\\n\\t\\t\\t// Update its state\\r\\n\\t\\t\\tthis.addToHandlerCache(reveal);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n/*\\r\\nCompute the internal state of the widget\\r\\n*/\\r\\nAppearWidget.prototype.execute = function() {\\r\\n\\tvar self = this;\\r\\n\\t// Attribute mapping\\r\\n\\tthis.attr = {\\r\\n\\t\\t// Which attributes map to which element\\r\\n\\t\\tmap: {\\r\\n\\t\\t\\treveal: {\\r\\n\\t\\t\\t\\t\\\"class\\\":1,\\r\\n\\t\\t\\t\\tposition:1,\\r\\n\\t\\t\\t\\tretain:1,\\r\\n\\t\\t\\t\\tstate:1,\\r\\n\\t\\t\\t\\tstyle:1,\\r\\n\\t\\t\\t\\ttag:1,\\r\\n\\t\\t\\t\\ttype:1\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\tbutton: {\\r\\n\\t\\t\\t\\t\\\"button-class\\\":1,\\r\\n\\t\\t\\t\\t\\\"button-style\\\":1,\\r\\n\\t\\t\\t\\t\\\"button-tag\\\":1,\\r\\n\\t\\t\\t\\ttooltip:1,\\r\\n\\t\\t\\t\\tselectedClass:1\\r\\n\\t\\t\\t}\\r\\n\\t\\t},\\r\\n\\t\\t// Rename duplicate attributes later\\r\\n\\t\\trename: {\\r\\n\\t\\t\\t\\\"button-class\\\":\\\"class\\\",\\r\\n\\t\\t\\t\\\"button-style\\\":\\\"style\\\",\\r\\n\\t\\t\\t\\\"button-tag\\\":\\\"tag\\\"\\r\\n\\t\\t},\\r\\n\\t\\t// Initialize empty containers\\r\\n\\t\\tbutton: {},\\r\\n\\t\\treveal: {}\\r\\n\\t};\\r\\n\\t// Loop widget attributes\\r\\n\\t$tw.utils.each(this.attributes,function(val,key) {\\r\\n\\t\\tvar next;\\r\\n\\t\\t// Loop mappings\\r\\n\\t\\t$tw.utils.each(\\r\\n\\t\\t\\tself.attr.map,function(attr,el) {\\r\\n\\t\\t\\t// Loop attributes for element\\r\\n\\t\\t\\t$tw.utils.each(Object.keys(attr),function(attr) {\\r\\n\\t\\t\\t\\t// Attribute for element?\\r\\n\\t\\t\\t\\tif(attr == key) {\\r\\n\\t\\t\\t\\t\\t// Store attr value\\r\\n\\t\\t\\t\\t\\tself.attr[el][key] = val;\\r\\n\\t\\t\\t\\t\\t// Next attribute\\r\\n\\t\\t\\t\\t\\tnext = false;\\r\\n\\t\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t});\\r\\n\\t\\t\\treturn next;\\r\\n\\t\\t});\\r\\n\\t});\\r\\n\\t// Handle all other attributes...\\r\\n\\t// Store current tiddler\\r\\n\\tthis.currentTiddler = this.getVariable(\\\"currentTiddler\\\");\\r\\n\\t// Default button label\\r\\n\\tthis.show = this.getValue(this.attributes.show,\\\"show\\\");\\r\\n\\t// Label for hide-button\\r\\n\\tthis.hide = this.getValue(this.attributes.hide,\\\"hide\\\");\\r\\n\\t// None defined?\\r\\n\\tif(!this.hide) {\\r\\n\\t\\t// Use default label\\r\\n\\t\\tthis.hide = this.show;\\r\\n\\t}\\r\\n\\t// Whether to only reveal the content once\\r\\n\\tthis.once = this.attributes.once && this.attributes.once !== \\\"false\\\";\\r\\n\\t// State shorthand\\r\\n\\tthis.$state = this.attributes.$state;\\r\\n\\t// Reveal mode\\r\\n\\tthis.mode = this.getValue(this.attributes.mode,\\\"mode\\\");\\r\\n\\t// Is this a handler instance?\\r\\n\\tthis.handle = this.attributes.handle;\\r\\n\\t// Remotely handle this instance?\\r\\n\\tthis.handler = this.attributes.handler;\\r\\n\\t// For that case we take these variables along\\r\\n\\tthis.handlerVariables = (this.attributes.variables || \\\"\\\") + \\\" currentTiddler\\\";\\r\\n\\t// Whether or not to keep popups\\r\\n\\tthis.keep = [\\\"yes\\\",\\\"true\\\"].indexOf(\\r\\n\\t\\t\\t(this.getValue(this.attributes.keep,\\\"keep\\\")||\\\"\\\").toLocaleLowerCase()\\r\\n\\t\\t) >- 1;\\r\\n\\t// No explicit state?\\r\\n\\tif(!this.attr.reveal.state) {\\r\\n\\t\\t// Calculate fallback state\\r\\n\\t\\tthis.attr.reveal.state =\\r\\n\\t\\t\\t\\tthis.getValue(undefined,\\\"default-state\\\") +\\r\\n\\t\\t\\t\\tthis.currentTiddler +\\r\\n\\t\\t\\t\\tthis.getStateQualifier() + \\\"/\\\" +\\r\\n\\t\\t\\t\\t(this.attr.reveal.type ? this.attr.reveal.type + \\\"/\\\" : \\\"\\\") +\\r\\n\\t\\t\\t\\t(this.mode ? this.mode + \\\"/\\\" : \\\"\\\") +\\r\\n\\t\\t\\t\\t(this.once ? \\\"once/\\\" : \\\"\\\") +\\r\\n\\t\\t\\t\\t// Append state suffix, if given\\r\\n\\t\\t\\t\\t(this.$state ? \\\"/\\\" + this.$state : \\\"\\\");\\r\\n\\t}\\r\\n};\\r\\n\\r\\n/*\\r\\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\r\\n*/\\r\\nAppearWidget.prototype.refresh = function(changedTiddlers) {\\r\\n\\tvar changedAttributes = this.computeAttributes();\\r\\n\\t// Any changed attributes?\\r\\n\\tif(Object.keys(changedAttributes).length) {\\r\\n\\t\\t// Refresh\\r\\n\\t\\tthis.refreshSelf();\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\t// Global handler?\\r\\n\\tif(this.handle) {\\r\\n\\t\\t// Handle refreshes\\r\\n\\t\\tthis.refreshHandler();\\r\\n\\t}\\r\\n\\t// Check if we're refreshing children\\r\\n\\treturn this.refreshChildren(changedTiddlers);\\r\\n};\\r\\n\\r\\n/*\\r\\nRetrieves a widget parameter as either attribute, config-tiddler default or hard-coded fallback.\\r\\n*/\\r\\nAppearWidget.prototype.getValue = function(value,attr){\\r\\n\\tvar def,undef,\\r\\n\\t\\t// Global fallbacks\\r\\n\\t\\tfallbacks = {\\r\\n\\t\\t\\tshow: \\\"»\\\",\\r\\n\\t\\t\\t\\\"default-state\\\": \\\"$:/temp/appear/\\\"\\r\\n\\t\\t};\\r\\n\\t// If there is no value...\\r\\n\\tif(value === undefined) {\\r\\n\\t\\t// Get default for it\\r\\n\\t\\tdef = this.wiki.getTiddler(\\\"$:/plugins/tobibeer/appear/defaults/\\\" + attr);\\r\\n\\t\\t// Got one?\\r\\n\\t\\tif(def) {\\r\\n\\t\\t\\t// Check if set to undefined\\r\\n\\t\\t\\tundef = def.getFieldString(\\\"undefined\\\");\\r\\n\\t\\t\\t// Not undefined?\\r\\n\\t\\t\\tif(!undef || undef === \\\"false\\\") {\\r\\n\\t\\t\\t\\t// Read default\\r\\n\\t\\t\\t\\tvalue = def.getFieldString(\\\"text\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t// If we still have no value\\r\\n\\tif(value === undefined) {\\r\\n\\t\\t// Try to read from fallbacks\\r\\n\\t\\tvalue = fallbacks[attr];\\r\\n\\t}\\r\\n\\treturn value;\\r\\n};\\r\\n\\r\\n/*\\r\\nSet child-widget attributes for a given element,\\r\\ndepending on the parsed widget attributes\\r\\n*/\\r\\nAppearWidget.prototype.setAttributes = function(node,element) {\\r\\n\\tvar self = this,\\r\\n\\t\\t// Initialize attributes object\\r\\n\\t\\tresult = {};\\r\\n\\t// Loop attributes defined for this element\\r\\n\\t$tw.utils.each(Object.keys(this.attr.map[element]),function(attr) {\\r\\n\\t\\tvar val,\\r\\n\\t\\t\\t// Check if we needed to rename this attribute\\r\\n\\t\\t\\tname = self.attr.rename[attr];\\r\\n\\t\\t// Not renamed?\\r\\n\\t\\tif(!name) {\\r\\n\\t\\t\\t// Take attribute name as is\\r\\n\\t\\t\\tname = attr;\\r\\n\\t\\t}\\r\\n\\t\\t// Read as widget value, default, or fallback\\r\\n\\t\\tval = self.getValue(self.attr[element][attr],attr);\\r\\n\\t\\t// Class attribute? (always for the button, for the reveal only if undefined)\\r\\n\\t\\tif(name === \\\"class\\\") {\\r\\n\\t\\t\\t// Construct classes\\r\\n\\t\\t\\tval = [\\r\\n\\t\\t\\t\\t\\\"appear\\\",\\r\\n\\t\\t\\t\\t\\\"appear-\\\" + element,\\r\\n\\t\\t\\t\\t(element === \\\"reveal\\\" && self.keep ? \\\"tc-popup-keep\\\" : \\\"\\\"),\\r\\n\\t\\t\\t\\t(self.mode ? \\\"appear-\\\" + self.mode : \\\"\\\"),\\r\\n\\t\\t\\t\\t(self.once ? \\\"appear-once\\\" : \\\"\\\"),\\r\\n\\t\\t\\t\\t(val || \\\"\\\")\\r\\n\\t\\t\\t].join(\\\" \\\");\\r\\n\\t\\t}\\r\\n\\t\\t// Do we have a value?\\r\\n\\t\\tif(val !== undefined) {\\r\\n\\t\\t\\t// Set an element tag?\\r\\n\\t\\t\\tif(name === \\\"tag\\\") {\\r\\n\\t\\t\\t\\t// Then set it for the parseTreeNode directly\\r\\n\\t\\t\\t\\tnode.tag = val;\\r\\n\\t\\t\\t// Set an attribute?\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t// Add to attribute object\\r\\n\\t\\t\\t\\tresult[name] = {type: \\\"string\\\", value: val};\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t});\\r\\n\\t// Return all attributes as an object\\r\\n\\treturn result;\\r\\n};\\r\\n\\r\\n/*\\r\\nRetrieves handler cache, creates if not existing or told to\\r\\n*/\\r\\nAppearWidget.prototype.getHandlerCache = function(handler,create) {\\r\\n\\t// Retrieve cache for handler\\r\\n\\tvar cache = handlerCache[handler];\\r\\n\\t// If not existing or asked to be created\\r\\n\\tif(!cache || create){\\r\\n\\t\\t// Create new cache for handler\\r\\n\\t\\thandlerCache[handler] = {\\r\\n\\t\\t\\t// For these states\\r\\n\\t\\t\\thandled: {},\\r\\n\\t\\t\\t// Refresh list\\r\\n\\t\\t\\thandle: {}\\r\\n\\t\\t};\\r\\n\\t\\tcache = handlerCache[handler];\\r\\n\\t}\\r\\n\\treturn cache;\\r\\n};\\r\\n\\r\\n/*\\r\\nRetrieve notifier list for global handler and create contents accordingly\\r\\n*/\\r\\nAppearWidget.prototype.refreshHandler = function() {\\r\\n\\tvar self = this,\\r\\n\\t\\t// Get cache for handler\\r\\n\\t\\tcache = this.getHandlerCache(this.handle),\\r\\n\\t\\t// Load refresh items from global cache for handler\\r\\n\\t\\thandle = cache.handle;\\r\\n\\t// Got anything to handle?\\r\\n\\tif(Object.keys(handle).length) {\\r\\n\\t\\t// Loop refresh handles\\r\\n\\t\\t$tw.utils.each(handle, function(node,state) {\\r\\n\\t\\t\\t// Remove existing child node\\r\\n\\t\\t\\tself.removeChildNode(state);\\r\\n\\t\\t\\t// Render as child node\\r\\n\\t\\t\\tself.children.push(self.makeChildWidget(node));\\r\\n\\t\\t\\t// Rrnder child\\r\\n\\t\\t\\tself.children[self.children.length - 1].render(self.parentDomNode,self.nextSibling);\\r\\n\\t\\t});\\r\\n\\t\\t// Remove entries\\r\\n\\t\\thandlerCache[this.handle].handle = {};\\r\\n\\t}\\r\\n};\\r\\n\\r\\n/*\\r\\nRemoves a child node of a handler for a given state\\r\\n*/\\r\\nAppearWidget.prototype.removeChildNode = function(state) {\\r\\n\\tvar self = this;\\r\\n\\t// Loop all child widgets of handler\\r\\n\\t$tw.utils.each(this.children, function(node,index) {\\r\\n\\t\\t// Same state?\\r\\n\\t\\tif(node.children[0].state === state) {\\r\\n\\t\\t\\t// Remove any domNodes\\r\\n\\t\\t\\tnode.removeChildDomNodes();\\r\\n\\t\\t\\t// Delete child widget\\r\\n\\t\\t\\tself.children.splice(index);\\r\\n\\t\\t\\t// Done\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t});\\r\\n};\\r\\n\\r\\n/*\\r\\nChecks and updates the state for a reveal widget handling remote content\\r\\n*/\\r\\nAppearWidget.prototype.addToHandlerCache = function(reveal) {\\r\\n\\tvar self = this,\\r\\n\\t\\t// Only one per state\\r\\n\\t\\tstate = reveal.attributes.state.value,\\r\\n\\t\\t// Retrieve cache for handler\\r\\n\\t\\tcache = this.getHandlerCache(this.handler),\\r\\n\\t\\t// Retrieve parseTree for state as cached for the handler\\r\\n\\t\\tcached = cache.handled[state],\\r\\n\\t\\t// Create vars widget wrapper containing the reveal\\r\\n\\t\\tvars = {type:\\\"vars\\\", children:[reveal], attributes:{}};\\r\\n\\t// Loop\\r\\n\\t$tw.utils.each(\\r\\n\\t\\t// Handler variables\\r\\n\\t\\t(this.handlerVariables || \\\"\\\").split(\\\" \\\"),\\r\\n\\t\\tfunction(v) {\\r\\n\\t\\t\\t// No empty strings\\r\\n\\t\\t\\tv = v.trim();\\r\\n\\t\\t\\tif(v){\\r\\n\\t\\t\\t\\t// Store variable as vars widget attribute by...\\r\\n\\t\\t\\t\\tvars.attributes[v] = {\\r\\n\\t\\t\\t\\t\\ttype: \\\"string\\\",\\r\\n\\t\\t\\t\\t\\t// Fetching the current variable value\\r\\n\\t\\t\\t\\t\\tvalue: (self.getVariable(v) || \\\"\\\").toString()};\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t);\\r\\n\\t// If the state for this reveal is not the cached one\\r\\n\\tif(vars !== cached) {\\r\\n\\t\\t// Add to refresh list, picked up by handler\\r\\n\\t\\tcache.handle[state] = vars;\\r\\n\\t\\t// Trigger refresh by writing to dummy temp tiddler for handler\\r\\n\\t\\tthis.wiki.setText(\\\"$:/temp/appear-handler/\\\"+this.handler,\\\"text\\\",undefined,state);\\r\\n\\t}\\r\\n};\\r\\n\\r\\n// Now we got a widget ready for use\\r\\nexports.appear = AppearWidget;\\r\\n\\r\\n})();\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/tobibeer/appear/defaults/show\":{\"title\":\"$:/plugins/tobibeer/appear/defaults/show\",\"text\":\"»\"},\"$:/plugins/tobibeer/appear/defaults/mode\":{\"title\":\"$:/plugins/tobibeer/appear/defaults/mode\",\"text\":\"block\"},\"$:/plugins/tobibeer/appear/defaults/keep\":{\"title\":\"$:/plugins/tobibeer/appear/defaults/keep\",\"text\":\"yes\"},\"$:/plugins/tobibeer/appear/defaults/button-class\":{\"title\":\"$:/plugins/tobibeer/appear/defaults/button-class\",\"text\":\"tc-btn-invisible tc-tiddlylink\"},\"$:/plugins/tobibeer/appear/defaults/default-state\":{\"title\":\"$:/plugins/tobibeer/appear/defaults/default-state\",\"text\":\"$:/temp/appear/\"},\"$:/plugins/tobibeer/appear/popup.js\":{\"title\":\"$:/plugins/tobibeer/appear/popup.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/tobibeer/appear/popup.js\\r\\ntype: application/javascript\\r\\nmodule-type: utils\\r\\n\\r\\nAn enhanced version of the core Popup to support:\\r\\n* absolute popups\\r\\n* preview popups\\r\\n* popup z-index\\r\\n\\r\\n@preserve\\r\\n\\\\*/\\r\\n(function () {\\r\\n  /*jslint node: true, browser: true */\\r\\n  /*global $tw: false */\\r\\n  'use strict';\\r\\n\\r\\n  const Popup = require('$:/core/modules/utils/dom/popup.js').Popup,\\r\\n    Reveal = require('$:/core/modules/widgets/reveal.js').reveal,\\r\\n    refreshCoreReveal = Reveal.prototype.refresh;\\r\\n\\r\\n  const originalShow = Popup.prototype.show;\\r\\n\\r\\n  /*\\r\\n  Hijack and overwrite core Popup show() method\\r\\n    => required for absolute popup positioning, rather than relative\\r\\n  */\\r\\n  Popup.prototype.show = function (options) {\\r\\n    // fix https://github.com/tobibeer/tw5-appear/issues/5\\r\\n    if (!options.domNode) {\\r\\n      return originalShow.call(this, options);\\r\\n    }\\r\\n    // The button\\r\\n    let cancelLevel;\\r\\n    let el = options.domNode;\\r\\n    // Check if button absolutely positioned\\r\\n    let absolute = $tw.utils.hasClass(el, 'tc-popup-absolute');\\r\\n    // Find out what was clicked on\\r\\n    let info = this.popupInfo(el);\\r\\n    // Helper to calculate the absolte offset\\r\\n    const calcAbsoluteOffset = function (el) {\\r\\n      let e = el;\\r\\n\\t\\t\\tlet x = 0;\\r\\n\\t\\t\\tlet y = 0;\\r\\n      do {\\r\\n        x += e.offsetLeft || 0;\\r\\n        y += e.offsetTop || 0;\\r\\n        e = e.offsetParent;\\r\\n      } while (e);\\r\\n      return { left: x, top: y };\\r\\n    };\\r\\n    let offset = {\\r\\n      left: el.offsetLeft,\\r\\n      top: el.offsetTop,\\r\\n    };\\r\\n    // Level to be canceled\\r\\n    cancelLevel = info.popupLevel;\\r\\n    // If we clicked on a handle\\r\\n    if (info.isHandle) {\\r\\n      // Next level\\r\\n      cancelLevel++;\\r\\n    }\\r\\n    // Cancel any higher level popups\\r\\n    this.cancel(cancelLevel);\\r\\n    // Store the popup details if not already there\\r\\n    if (this.findPopup(options.title) === -1) {\\r\\n      // Store the popup details\\r\\n      this.popups.push({\\r\\n        title: options.title,\\r\\n        wiki: options.wiki,\\r\\n        domNode: el,\\r\\n      });\\r\\n    }\\r\\n    // Calculate absolute offset?\\r\\n    offset = absolute ? calcAbsoluteOffset(el) : offset;\\r\\n    // Set the state tiddler\\r\\n    options.wiki.setTextReference(options.title, '(' + offset.left + ',' + offset.top + ',' + el.offsetWidth + ',' + el.offsetHeight + ')');\\r\\n    // Add the click handler if we have any popups\\r\\n    if (this.popups.length > 0) {\\r\\n      this.rootElement.addEventListener('click', this, true);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  // Hijack popupInfo() of core Popup ($tw.popup)\\r\\n  Popup.prototype.popupInfo = function (domNode) {\\r\\n    var popupCount,\\r\\n      isHandle = false,\\r\\n      node = domNode;\\r\\n    // First check ancestors to see if we're within a popup handle\\r\\n    while (node && popupCount === undefined) {\\r\\n      // When\\r\\n      if (\\r\\n        // This is a handle\\r\\n        $tw.utils.hasClass(node, 'tc-popup-handle') ||\\r\\n        // Or a sticky popup\\r\\n        $tw.utils.hasClass(node, 'tc-popup-keep')\\r\\n      ) {\\r\\n        // We set this flag (not exactly sure about the general idea here)\\r\\n        isHandle = true;\\r\\n      }\\r\\n      // When\\r\\n      if (\\r\\n        // It's a reveal\\r\\n        $tw.utils.hasClass(node, 'tc-reveal') &&\\r\\n        // Being a popup\\r\\n        ($tw.utils.hasClass(node, 'tc-popup') ||\\r\\n          // Or a popup-handle reveal (the choice of name seems confusing)\\r\\n          $tw.utils.hasClass(node, 'tc-popup-handle'))\\r\\n      ) {\\r\\n        // Calculate popup level via zIndex\\r\\n        popupCount = parseInt(node.style.zIndex) - 1000;\\r\\n      }\\r\\n      // Next Parent\\r\\n      node = node.parentNode;\\r\\n    }\\r\\n    // Create info object\\r\\n    var info = {\\r\\n      popupLevel: popupCount || 0,\\r\\n      isHandle: isHandle,\\r\\n    };\\r\\n    return info;\\r\\n  };\\r\\n\\r\\n  /*\\r\\n  Hijack core handleEvent\\r\\n  */\\r\\n  Popup.prototype.handleEvent = function (event) {\\r\\n    if (event.type === 'click') {\\r\\n      // Find out what was clicked on\\r\\n      var info = this.popupInfo(event.target),\\r\\n        cancelLevel = info.popupLevel - 1;\\r\\n      // Don't remove the level that was clicked on if we clicked on a handle\\r\\n      if (info.isHandle) {\\r\\n        if (cancelLevel < 0) {\\r\\n          cancelLevel = 1;\\r\\n        } else {\\r\\n          cancelLevel++;\\r\\n        }\\r\\n      }\\r\\n      // Cancel\\r\\n      this.cancel(cancelLevel);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  // Hijack readPopupState of core reveal widget to set zIndex\\r\\n  Reveal.prototype.refresh = function () {\\r\\n    var domNode,\\r\\n      result,\\r\\n      wasOpen = this.isOpen;\\r\\n    // Run core handler\\r\\n    result = refreshCoreReveal.apply(this, arguments);\\r\\n    // Reference to domNode\\r\\n    domNode = this.domNodes[0];\\r\\n    if (\\r\\n      // If the popup is now open AND\\r\\n      this.isOpen &&\\r\\n      // It was not before\\r\\n      (wasOpen !== this.isOpen ||\\r\\n        // Or does not have a zIndex\\r\\n        !domNode.style.zIndex) &&\\r\\n      // AND\\r\\n      // There actually is a domNode AND\\r\\n      domNode &&\\r\\n      // This is a popup reveal OR\\r\\n      (this.type === 'popup' ||\\r\\n        // It's a dropdown-reveal\\r\\n        ($tw.utils.hasClass(domNode, 'tc-block-dropdown') && $tw.utils.hasClass(domNode, 'tc-reveal')))\\r\\n    ) {\\r\\n      // Dynamically set z-index\\r\\n      domNode.style.zIndex = 1000 + $tw.popup.popups.length;\\r\\n    }\\r\\n    return result;\\r\\n  };\\r\\n})();\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"utils\"},\"$:/plugins/tobibeer/appear/readme\":{\"title\":\"$:/plugins/tobibeer/appear/readme\",\"text\":\"This plugin provides the ''$appear'' widget that can render popups and sliders (inline or block) as well as accordion menus.\\n\\n!! Attributes\\r\\n; type\\r\\n: set to `popup` to have the content appear as a popup\\r\\n; show\\r\\n: the button label\\r\\n; hide\\r\\n: the hide button label\\r\\n; mode\\r\\n: either `block` or `inline`, with respect to the inner content\\r\\n: any other mode is interpreted as block mode, without the default styles applying, e.g. drop-shadows\\r\\n; once\\r\\n: allows to click the button once, then hides it (unless the state is deleted)\\r\\n; $state\\r\\n: the widget calculates a state for you, use this to append a simple id\\r\\n; state\\r\\n: alternatively, specify a fully qualified state\\r\\n; keep\\r\\n: make popups sticky when `yes` or `true`\\r\\n; handle / handler / variables\\r\\n: allows to take the popup contents out of the flow and render them elsewhere on the page\\r\\n: required to properly create popups in table cells and other constained elements\\r\\n: specify variables to take along\\n\\n<br>\\n\\n; documentation / examples / demos...\\r\\n: http://tobibeer.github.io/tw5-plugins#appear\\r\\n\"},\"$:/plugins/tobibeer/appear/styles\":{\"title\":\"$:/plugins/tobibeer/appear/styles\",\"tags\":\"$:/tags/Stylesheet\",\"text\":\"\\\\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline html\\n\\n<pre>.tc-reveal.appear-block,\\r\\n.tc-popup.appear {\\r\\n\\tborder-radius: 5px;\\r\\n\\tpadding: 1px 1em;\\r\\n\\t<<box-shadow \\\"2px 2px 4px rgba(0,0,0,0.3)\\\">>;\\r\\n}\\r\\n.tc-popup.appear {\\r\\n\\tpadding: 0 1em;\\r\\n\\tbackground: <<colour background>>;\\r\\n}\\r\\n.appear-reveal.appear-inline{\\r\\nmargin-left:5px;\\r\\n}\\r\\n.appear-reveal.appear-inline.appear-once{\\r\\nmargin-left:0;\\r\\n}</pre>\"}}}"}